# 浏览器加载、解析、渲染

[TOC]

## 前言 了解浏览器加载、解析、渲染的理由



* 了解加载：可以在引用外部样式文件，外部js时，将他们放到合适的位置，使浏览器以最快的速度将文件加载完毕。
* 了解解析：可以在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。
* 了解渲染：在设置元素属性，编写js文件时，可以减少”reflow“、”repaint“的消耗。

## 一、浏览器的主要功能和工作流程

浏览器的主要功能是将用户选择的web资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是HTML，也包括PDF、image及其他格式。用户用URI（Uniform Resource Identifier统一资源标识符）来指定所请求资源的位置，通过DNS查询，将网址转换为IP地址。

工作流程：

1. 输入网址
2. 浏览器查找域名的IP地址
3. 浏览器给web服务器发送一个HTTP请求
4. 网站服务的永久重定向响应 
5. 浏览器跟踪重定向地址。现在，浏览器知道了要访问的正确地址，所以它会发送另一个获取请求
6. 服务器“处理”请求，服务器接收到获取请求，然后处理并返回一个响应
7. 服务器发回一个HTML响应
8. 浏览器开始显示HTML
9. 浏览器发送请求，以获取嵌入在HTML中的对象。在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。这些文件就包括CSS/JS/图片等资源，这些资源的地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等…

## 二、具体完成步骤

当浏览器获得一个html文件时，会“自上而下”加载，并在加载过程中进行解析渲染。 
解析： 

1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。 
2. 将CSS解析成 CSS Rule Tree 。 
3. 根据DOM树和CSSOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像 Header 或 display:none 的东西就没必要放在渲染树中了

HTML页面加载和解析流程 
1. 用户输入网址（假设是个html页面，并且是第一次访问），浏览器向服务器发出请求，服务器返回html文件； 
2. 浏览器开始载入html代码，发现＜head＞标签内有一个＜link＞标签引用外部CSS文件； 
3. 浏览器又发出CSS文件的请求，服务器返回这个CSS文件； 
4. 浏览器继续载入html中＜body＞部分的代码，并且CSS文件已经拿到手了，可以开始渲染页面了； 
5. 浏览器在代码中发现一个＜img＞标签引用了一张图片，向服务器发出请求。此时浏览器不会等到图片下载完，而是继续渲染后面的代码； 
6. 服务器返回图片文件，由于图片占用了一定面积，影响了后面段落的排布，因此浏览器需要回过头来重新渲染这部分代码； 
7. 浏览器发现了一个包含一行Javascript代码的＜script＞标签，赶快运行它； 
8. Javascript脚本执行了这条语句，它命令浏览器隐藏掉代码中的某个＜div＞ （style.display=”none”）。突然少了这么一个元素，浏览器不得不重新渲染这部分代码； 
9. 终于等到了＜/html＞的到来，浏览器泪流满面…… 
10. 等等，还没完，用户点了一下界面中的“换肤”按钮，Javascript让浏览器换了一下＜link＞标签的CSS路径； 
11. 浏览器召集了在座的各位＜div＞＜span＞＜ul＞＜li＞们，“大伙儿收拾收拾行李，咱得重新来过……”，浏览器向服务器请求了新的CSS文件，重新渲染页面。

### Reflow

浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。 

产生原因：

* 页面初始化的时候；

* 操作DOM时；

* 某些元素的尺寸变了；

* 如果 CSS 的属性发生变化了。

### Repaint

如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。 

### 减少Reflow和Repaint

* 不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className
* 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。
* 为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。
* 千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。

## CSS优化

CSS选择符是从右到左进行匹配的，若想匹配`#nav li`，会首先去寻找所有的`li`，然后再去确定它的父元素或祖先元素是不是`#nav`。由此可知，可进行以下优化：

* dom深度尽量浅
* 减少inline JavaScript、css的数量
* 使用现代合法的css属性
* 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素
* 避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符：#tp p{} 子选择符：#tp>p{}
* 避免使用通配符

## JavaScript载入优化

* 将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染
* 尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此
* 采用无阻塞下载 JavaScript 脚本的方法：
  * 使用script标签的 defer 属性
  * 使用动态创建的script元素来下载并执行代码