# 鉴权

## session-cookie

在服务器端创建一个会话(session),将同一个客户端的请求都维护在各自得会会话中，每当请求到达服务器端的时候，先去查一下该客户端有没有在服务器端创建session，如果有则已经认证成功了，否则就没有认证。

### 过程

1. 服务器在接受客户端首次访问时在服务器端创建session，然后保存session(我们可以将session保存在内存中，也可以保存在redis中，推荐使用后者)，然后给这个session生成一个唯一的标识字符串,然后在响应头中种下这个唯一标识字符串。
2. 签名。这一步只是对sid进行加密处理，服务端会根据这个secret密钥进行解密。（非必需步骤）
3. 浏览器中收到请求响应的时候会解析响应头，然后将sid保存在本地cookie中，浏览器在下次http请求的请求头中会带上该域名下的cookie信息
4. 服务器在接受客户端请求时会去解析请求头cookie中的sid，然后根据这个sid去找服务器端保存的该客户端的session，然后判断该请求是否合法。

### 弊端

* 服务器内存开销大，每做一次应用认证,应用就会在服务端做一次记录,以方便用户下次请求时使用,通常来讲session保存在内存中,随着认证用户的增加,服务器的消耗就会很大.
* 易遭受CSRF攻击

## Token

当用户第一次登录后，服务器生成一个token并将此token返回给客户端，以后客户端只需带上这个token前来请求数据即可，无需再次带上用户名和密码。

最简单的token组成:uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接token请求服务器)。还可以把不变的参数也放进token，避免多次查库。

服务器只需要对浏览器传来的token值进行**解密**，解密完成后进行用户数据的**查询**，如果查询成功，则通过认证

### 优点

* 可以避开同源策略（存储在web storage中）
* 可以避免CSRF攻击
* 可以在多个服务间共享

### 缺点

相比于session-cookie来说，token需要服务端花费更多的时间和性能来对token进行解密验证

## JWT

JWT，JSON Web Tokens。服务器认证后，生成一个JSON对象返回到前端。前端在与服务器通信时，都要发送这个JSON对象，服务器完全只靠这个对象认定用户身份。

### 组成结构

* Header
* Payload
* Signature

即Header.Payload.Signature

#### Header

描述JWT元数据

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

#### Payload

Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。

也可以自定义其他字段

#### Signature

Signature 部分是对前两部分的签名，防止数据篡改。

#### 串行化

使用Base64URL算法来串型化Header 和 Payload

### 使用方式

存储在cookie或localStorage中

### 特点

* 默认不加密，也可以在生成token后加密
* 不加密情况下，不推荐将秘密数据写入JWT
* JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数
* JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
* JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。
* 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

### 失效的方法

* 将 token 存入 DB（如 Redis）中，失效则删除；但增加了一个每次校验时候都要先从 DB 中查询 token是否存在的步骤，而且违背了 JWT 的无状态原则（不推荐）。
* 维护一个 token 黑名单，失效则加入黑名单中(用的比较多)。
* 在 JWT 中增加一个版本号字段，失效则改变该版本号。
* 在服务端设置加密的 key 时，为每个用户生成唯一的 key，失效则改变该 key。

## 参考资料

https://juejin.im/post/5c6e6063f265da2da53ec8f3#heading-8

http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html